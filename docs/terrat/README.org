Terrateam is an application that translates repository events into execution of
CI/CD executions, specifically running Terraform.  Terrateam is composed to two
elements: a backend which receives the events, making decisions, and an runner
which executes the decisions the backend has created.  The runner needs to run
in a context that it can successfully execute Terraform.  The backend is a
decision engine for translating events into the work of the runner.

The decision engine is agnostic to the service, it just needs to have a
representation of what has changed in order to understand what to run.

The workflow of the decision engine is:

1. Receive an event.  We may choose to not proceed if the event does not
   correspond to an action we want to perform.
2. Create a work manifest from the change.  We need to collect information about
   the change and we may choose not to execute a work manifest, for example if
   the change does not impact Terraform at all.
3. Decide on action for the work manifest.  Work manifests are made
   optimistically and we may not choose not to run the work manifest once we
   evaluate it in the correct context.  Specifically, the place we evaluate the
   work manifest guarantees each repository is being acted on in serial, whereas
   we may create work manifests concurrently.

If it is decided to execute the running, it checks in to the backend to confirm
that it is running the correct changes.  If it is not, it will be canceled.

Terrateam is meant to work against other integrations, both repositories and
executors for the runner.  GitHub is the primary target with Bitbucket Cloud
being a close second.

* Glossary
- ~change~ - This is the tuple of ~(directory, workspace)~.  A modification to a
  file results in a ~change~ which can then be planned or applied.
- ~work manifest~ or ~WM~ - The definition of work and the results to be done.
  A WM has:
  1. ~id~ - Each WM is uniquely identified.
  2. ~changes~ - The list of ~(directory, workspace)~ tuples that that will be
     executed on in this change.
  3. ~created_at~ - When the work manifest was created.
  4. ~completed_at~ - When the work manifest completed, this is regardless of
     its state.
  5. ~state~ - The state of the WM, one of the following.  note that a WM can
     complete or be aborted, but it does not contain a "success" or "failure".
     The ~work manifest results~ needs to be inspected to determine what
     succeeded and what failed.
     1. ~queued~ - The WM has been created but not acted on.
     2. ~running~ - The WM is being processed.  It maybe be running a
        pipeline/action or it may just be being evaluated.
     3. ~aborted~ - In evaluating the WM, it was decided running it was not
        needed.
     4. ~completed~ - The WM ran and completed.
- ~run type~ - The type of operation: ~autoplan~, ~autoapply~, ~plan~, ~apply~
- ~unified run type~ - The class of run type: ~plan~ or ~apply~.

* Work Manifest State Transitions

| From/To   | Queued | Running | Aborted | Completed |
|-----------+--------+---------+---------+-----------|
| Queued    | N      | Y       | Y       | N         |
| Running   | N      | N       | Y       | Y         |
| Aborted   | N      | N       | N       | N         |
| Completed | N      | N       | N       | N         |

* Operations
There are two Terraform operations that can be executed with Terrateam: ~plan~
and ~apply~.  These come in two flavors internally ~plan~ and ~autoplan~ and
~apply~ any ~autoapply~, the distinction between ~plan~ and ~apply~ are
initiated manually by a customer and the ~auto~ versions are initiated
indirectly due to a customer action, such as creating a change, pushing an
update to a change, or merging a change.

** Plan
Plans have the following semantics (per repository):

1. Multiple ~plan~ operations can be executing concurrently.
2. A ~plan~ cannot be executing if an ~apply~ is executing.
3. A ~plan~ can be repeatedly executed.

** Apply
Applies have the following semantics (per repository):

1. An ~apply~ has higher priority than a ~plan~.
2. An ~apply~ is mutually exclusive with all other operations.
3. All changes in the ~apply~ must have a plan on the change id.
4. The most recent ~plan~ for all changes that will be applied must be
   successful.
5. The change must either have no other applies, or be explicitly unlocked, or
   any applied changes must be merged into the default branch.

* Evaluating an Event
For the scope of this document, only events that correspond to code changes are
discussed.  Other administrative events might be handled as well, for example
managing GitHub Installation.  Unlocking is also not addressed here.

To evaluate an GitHub event, one of the following is true:

1. Pull request open
2. Pull request sync
3. Pull request close
4. Issue comment
   1. Comment is ~terrateam plan ...~
   2. Comment is ~terrateam apply ...~

* Evaluating Pull Request & Repository
If the event corresponds to a possible work manifest, the pull request is then
evaluated.  We will do as much up-front evaluation as possible for two reasons:

1. We do not want to make a WM if we know we'll never do the work.
2. We can inform the user quickly, making a better experience.

This means all events are evaluated based on how the repository looks now.  For
example, if a user initiated ~terrateam plan~ and immediately after initiated a
~terrateam apply~, a WM of the ~apply~ would not be created because we would see
that there are no plans yet.  The queue has a plan but we do not want the
~apply~ to be issued until after the plan is done. Similarly, if a user
initiated a ~plan~ and we know there is an ~apply~ in the queue for the same
~change~, we could inform them that we have queued the ~plan~ but that it might
take a little will to start because the running ~apply~.

Steps in evaluating:

1. Conditions where no run is performed and inform the user:
   1. The ~unified run type~ is ~apply~ and a plan does not exist for every
      ~change~.  We cannot run an ~apply~ without a plan.
   2. The ~unified run type~ is ~apply~ and there exists a ~change~ which is
      owned by another PR (an ~apply~ has been done on it but not merged).  We
      cannot execute an ~apply~ on a ~change~ that is still pending in another
      PR.
   3. The PR state is ~closed~ and applies have been executed on the PR.  If an
      ~apply~ has been done on a PR but it is not being merged, then the user is
      in a situation where the change will not be put into the mainline and they
      have caused drift.
   4. The ~unified run type~ is ~apply~ and a ~change~ has been applied and
      merged by another PR, we need to plan again.

* Evaluating a Work Manifest
Each work manifest is evaluated for what action to perform with it.  The
possible actions are running the WM or aborting it.

* Locking
Terrateam ensures that changes are safely applied to the a user's
infrastructure.  It guarantees that:

1. If an apply is executing on a ~(repository, directory, workspace)~ no other
   applies or plans can execute on that same combination.
2. No further changes to the ~(repository, directory, workspace)~ may be applied
   until the change is merged into the default branch or explicitly unlocked.
3. If an apply fails, no changes may be applied to the ~(repository, directory,
   workspace)~ outside of the pull request that failed.

These guarantees are desirable because:

1. They ensure updates are only applied serially.
2. Further changes are not possible until the applied change has made its way
   into the default branch, ensuring it's visible in all further plans and
   applies.
3. On failure, the change is executed until it succeeds.

* Executing a GitHub Action Workflow
** Receive event
The events we handle:

1. Installation event:
   1. Create
   2. Suspend
   3. Resume
   4. Uninstall
2. Update to pull request:
   1. Create a pull request
   2. Synchronize a pull request (updating it)
   3. Closing a pull request (either by merge or just closing)
3. Commenting:
   1. ~terrateam plan~ - Execute a plan.
   2. ~terrateam apply~ - Execute an apply.

In the case of event types (2) and (3), we will construct a work manifest which
may be executed.  The output of this step is what pull request to operate on and
if it is an automatic operation or manual.

*** Data
1. ~run_type~: ~autoplan~, ~plan~, ~autoapply~, ~apply~.
2. ~repository~: ID of the repository.
3. ~pull_number~: Pull request number.

** Evaluate PR & Enqueue
We fetch the current state of the PR and collect the following information:

1. The state of the PR: ~open~, ~closed~, ~merged~.
2. The destination branch.
3. If the destination branch is the ~default_branch~.
4. The ~base_sha~ and the ~sha~ of the PR.
5. The ~(dir, workspace)~ list of changed files between the sha's.
6. The ~(dir, workspace)~ list of changed files when applying ~run_type~ and
   ~tag_query~.



We perform one of the following actions:

1. If the destination branch is not the ~default_branch~, do nothing.
2. If the PR is ~closed~:
   1. If any applies have happened in the pull request then comment on the PR
      that we are in a bad state.  Users will need to unlock the PR or open it
      again and merge to continue.
3. If the PR is ~merged~:
   1. 

--

1. If the ~run_type~ is an explicit run (~plan~ or ~apply~) and the PR
   destination branch is not to the ~default_branch~ of the repository, we
   comment on the PR that we cannot perform the operation due to the destination
   branch.
2. If the ~run_type~ is an explicit run (~autoplan~ or ~autoapply~) and the PR
   destination branch is not to the ~default_branch~ of the repository, we do
   nothing.
3. If there is a work manifest that is in a ~queued~ state that corresponds to
   the same ~base_sha~, ~sha~, ~run_type~, and ~tag_query~, do nothing.
4. Otherwise we write the following to the database:
   1. For the ~base_sha~ and ~sha~ of the change, we write the all of the change
      dirs/workspaces.  Noop on conflict.
   2. We create a work manifest for this change.
   3. Write the list of directories that will be run for this specific
      invocation (for example if there is a tag query, we may not run against
      all changed directories).
*** Data
1. ~base_sha~ - The SHA of the destination branch at the time of running this.
2. ~sha~ - The SHA of the change at the time of running this.
3. Changed dirs/workspaces - The list of all changed dirs and workspaces based
   on the ~base_sha~ and the ~sha~.
4. Filtered dirs/workspaces - The list of changed dirs and workspaces when
   filtering by the operation type and tag filter.

** Execute work manifest
After any change in state we execute any work manifests that are available.  To
do this we:

1. Select all work manifests that are ~queued~
2. For each work manifest, group by repository and rank based on priority and
   creation date.
   1. ~autoapply~ and ~apply~ have higher priority than ~autoplan~ and ~plan.
   2. Creation date is ordered oldest to newest.
3. Sort all work manifests by creation date and take the top ranked work
   manifest for each repository
4. Skip any rows that are being locked by a concurrent update.
5. Limit results to the first row.
6. Set state of work manifest to ~running~.

We now have a work manifest which we know needs some operation performed on it
but we do not know what.

| Scenario | Repository                                 | Row   | Outcome         |
|----------+--------------------------------------------+-------+-----------------|
|        1 | Running apply                              | Apply | Abort & Comment |
|        2 | Running plan                               | Apply | Noop            |
|        3 | Running apply                              | Plan  | Noop            |
|        4 | Running plan                               | Plan  | Run             |
|        5 | Another PR has locked the repo             | Plan  | Run             |
|        6 | Another PR has locked the repo             | Apply | Noop & Comment  |
|        7 | Not all change dirs have plans             | Apply | Noop & Comment  |
|        8 | Apply from PR later than plans for this PR | Apply | Noop & Comment  |
|        9 | All plans exist                            | Apply | Run             |

1. Only one apply for a repository can be running at a time, so if there is a
   running apply, 

*** Locked Repository
A locked repository is one where a pull request has some of its plans applied
and is either not merged and/or not all plans are applied.  There can only be
one PR in a repository that has locked it.  A repository is unlocked by either:

1. The pull request is merged and all changed directories are applied.
2. A user explicitly does ~terrateam unlock~.

*** Algorithm to Determine a if a Row Can Be Run
To determine if any pull request other than the current row is locking the
repository:

1. For each pull request find all dir/workspaces that have been applied.  This
   is necessary because imagine the following scenario: A users pushes commit C1
   which changes D1 and D2 and they apply D1.  They then push C2, which reverts
   D1, so this PR only has a diff on D2.  We now have drift because D1 does not
   actually reflect this change and if we were to merge it and unlock it, the
   system would not reflect the code.  Also, we need to maintain the lock
   because this PR has changed the system even though it looks like the only
   change (D2) has not been applied.  So we track all of these and we would
   allow the user to apply any directory that has been changed in the life time
   of the PR even if it is not reflected in the current diff.  To accomplish
   this: select all work manifests that are an apply and group them by
   pull_request, path, and workspace, ordered by completion time and take only
   the most recent run for each group.
2. For each pull request, determine the most recent ~base_sha~ and ~sha~.
3. Select the union of the direc
4. Collect all work manifest runs for the repository and group by pull_request,
   path, workspace, and order by completed time in descending order, and filter
   only applies.  We want to select only the most recent run.
5. Determine the ~base_sha~ and ~sha~ that the pull request is on.
6. Collect the dir/workspace for the most recent applies for the ~base_sha~ and
   ~sha~ pair the pull request is on.
7. Union the 
