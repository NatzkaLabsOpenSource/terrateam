main: STRING
##
## Ends in an error in state: 0.
##
## main' -> . main [ # ]
##
## The known suffix of the stack is as follows:
##
##

Block or attribute expected.

main: NEWLINE EQUAL
##
## Ends in an error in state: 1.
##
## list(NEWLINE) -> NEWLINE . list(NEWLINE) [ TRUE STRING RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NULL NOT_EQUAL NOT NEWLINE MULT MINUS LPAREN LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET LBRACE IS_EQUAL INTEGER IN IF IDENTIFIER HEREDOC GREATER_THAN_EQUAL GREATER_THAN FOR FLOAT FAT_ARROW FALSE EOF ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## NEWLINE
##

Block or attribute expected.

main: NEWLINE STRING
##
## Ends in an error in state: 4.
##
## main -> list(NEWLINE) . body EOF [ # ]
##
## The known suffix of the stack is as follows:
## list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Block or attribute expected.

main: IDENTIFIER TRUE
##
## Ends in an error in state: 7.
##
## block -> IDENTIFIER . block_labels LBRACE nonempty_list(NEWLINE) body RBRACE [ NEWLINE ]
## block_one_line -> IDENTIFIER . block_labels LBRACE RBRACE [ NEWLINE ]
## block_one_line -> IDENTIFIER . block_labels LBRACE attribute RBRACE [ NEWLINE ]
## identifier -> IDENTIFIER . [ EQUAL ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER
##

String or identifier expected in block definition.

main: IDENTIFIER STRING TRUE
##
## Ends in an error in state: 8.
##
## block_labels -> STRING . block_labels [ LBRACE ]
##
## The known suffix of the stack is as follows:
## STRING
##

String or identifier expected in block definition.

main: IDENTIFIER IDENTIFIER TRUE
##
## Ends in an error in state: 9.
##
## block_labels -> IDENTIFIER . block_labels [ LBRACE ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER
##

String or identifier expected in block definition.

main: IDENTIFIER LBRACE STRING
##
## Ends in an error in state: 13.
##
## block -> IDENTIFIER block_labels LBRACE . nonempty_list(NEWLINE) body RBRACE [ NEWLINE ]
## block_one_line -> IDENTIFIER block_labels LBRACE . RBRACE [ NEWLINE ]
## block_one_line -> IDENTIFIER block_labels LBRACE . attribute RBRACE [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER block_labels LBRACE
##

Expected attribute in single-line block definition.

main: IDENTIFIER LBRACE NEWLINE RPAREN
##
## Ends in an error in state: 15.
##
## nonempty_list(NEWLINE) -> NEWLINE . [ TRUE STRING RBRACE NULL NOT MINUS LPAREN LBRACKET LBRACE INTEGER IN IDENTIFIER HEREDOC FLOAT FALSE EOF ]
## nonempty_list(NEWLINE) -> NEWLINE . nonempty_list(NEWLINE) [ TRUE STRING RBRACE NULL NOT MINUS LPAREN LBRACKET LBRACE INTEGER IN IDENTIFIER HEREDOC FLOAT FALSE EOF ]
##
## The known suffix of the stack is as follows:
## NEWLINE
##

Expected attribute or block definition in block.

main: IDENTIFIER LBRACE NEWLINE STRING
##
## Ends in an error in state: 19.
##
## block -> IDENTIFIER block_labels LBRACE nonempty_list(NEWLINE) . body RBRACE [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER block_labels LBRACE nonempty_list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 15, spurious reduction of production nonempty_list(NEWLINE) -> NEWLINE
##

Expected attribute or block definition in block.

main: FALSE TRUE
##
## Ends in an error in state: 20.
##
## attribute -> identifier . EQUAL expr [ RBRACE NEWLINE ]
##
## The known suffix of the stack is as follows:
## identifier
##

Expected (=) for attribute definition or block labels for block definition.

main: FALSE EQUAL RPAREN
##
## Ends in an error in state: 21.
##
## attribute -> identifier EQUAL . expr [ RBRACE NEWLINE ]
##
## The known suffix of the stack is as follows:
## identifier EQUAL
##

Expected expression in attribute defintion, found symbol.

main: FALSE EQUAL NOT RPAREN
##
## Ends in an error in state: 25.
##
## unary_op -> NOT . expr_term [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## NOT
##

Expected expression after (!), found symbol.

main: FALSE EQUAL LPAREN RPAREN
##
## Ends in an error in state: 26.
##
## collection_expr -> LPAREN . FOR RPAREN [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> LPAREN . list(NEWLINE) expr_paren RPAREN [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Expected expression after opening parenthesis, found symbol.

main: FALSE EQUAL LPAREN FOR TRUE
##
## Ends in an error in state: 27.
##
## collection_expr -> LPAREN FOR . RPAREN [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN FOR
##

Expected closing parenthesis to reference "for" keyword as an identifier.

main: FALSE EQUAL LPAREN NEWLINE RPAREN
##
## Ends in an error in state: 29.
##
## expr_term -> LPAREN list(NEWLINE) . expr_paren RPAREN [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression, found symbol.

main: FALSE EQUAL MINUS RPAREN
##
## Ends in an error in state: 30.
##
## unary_op -> MINUS . expr_term [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## MINUS
##

Expected expression after minus (-), found symbol.

main: FALSE EQUAL LBRACKET RPAREN
##
## Ends in an error in state: 31.
##
## collection_expr -> LBRACKET . list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## collection_expr -> LBRACKET . list(NEWLINE) tuple RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Expected expression after opening bracket, found symbol.

main: FALSE EQUAL LBRACKET NEWLINE RPAREN
##
## Ends in an error in state: 32.
##
## collection_expr -> LBRACKET list(NEWLINE) . FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## collection_expr -> LBRACKET list(NEWLINE) . tuple RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression after opening bracket, found symbol.

main: FALSE EQUAL LBRACE RPAREN
##
## Ends in an error in state: 33.
##
## collection_expr -> LBRACE . list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## collection_expr -> LBRACE . list(NEWLINE) obj RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Expected expression after opening brace, found symbol.

main: FALSE EQUAL LBRACE NEWLINE RPAREN
##
## Ends in an error in state: 34.
##
## collection_expr -> LBRACE list(NEWLINE) . FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## collection_expr -> LBRACE list(NEWLINE) . obj RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression after opening brace, found symbol.

main: FALSE EQUAL IDENTIFIER TRUE
##
## Ends in an error in state: 37.
##
## expr_term -> IDENTIFIER . LPAREN list(NEWLINE) fun_args RPAREN [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## simple_expr -> IDENTIFIER . [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER
##

Expected operation after identifier, found literal.

main: FALSE EQUAL IDENTIFIER LPAREN RBRACKET
##
## Ends in an error in state: 38.
##
## expr_term -> IDENTIFIER LPAREN . list(NEWLINE) fun_args RPAREN [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER LPAREN
##

Expected expression in function call, found symbol.

main: FALSE EQUAL IDENTIFIER LPAREN NEWLINE RBRACKET
##
## Ends in an error in state: 39.
##
## expr_term -> IDENTIFIER LPAREN list(NEWLINE) . fun_args RPAREN [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER LPAREN list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression in function call, found symbol.

main: FALSE EQUAL LPAREN LPAREN RPAREN
##
## Ends in an error in state: 40.
##
## collection_expr -> LPAREN . FOR RPAREN [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> LPAREN . list(NEWLINE) expr_paren RPAREN [ LBRACKET DOT ]
## expr_term_paren -> LPAREN . list(NEWLINE) expr_paren RPAREN [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

Expected expression, found symbol.

main: FALSE EQUAL LPAREN LPAREN NEWLINE RPAREN
##
## Ends in an error in state: 41.
##
## expr_term -> LPAREN list(NEWLINE) . expr_paren RPAREN [ LBRACKET DOT ]
## expr_term_paren -> LPAREN list(NEWLINE) . expr_paren RPAREN [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression, found symbol.

main: FALSE EQUAL LPAREN IDENTIFIER TRUE
##
## Ends in an error in state: 42.
##
## expr_term -> IDENTIFIER . LPAREN list(NEWLINE) fun_args RPAREN [ LBRACKET DOT ]
## expr_term_paren -> IDENTIFIER . LPAREN list(NEWLINE) fun_args RPAREN [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## simple_expr -> IDENTIFIER . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER
##

Expected function call or operator, found unexpected symbol.

main: FALSE EQUAL LPAREN IDENTIFIER LPAREN RBRACKET
##
## Ends in an error in state: 43.
##
## expr_term -> IDENTIFIER LPAREN . list(NEWLINE) fun_args RPAREN [ LBRACKET DOT ]
## expr_term_paren -> IDENTIFIER LPAREN . list(NEWLINE) fun_args RPAREN [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER LPAREN
##

Expected expression in function call, found symbol.

main: FALSE EQUAL LPAREN IDENTIFIER LPAREN NEWLINE RBRACKET
##
## Ends in an error in state: 44.
##
## expr_term -> IDENTIFIER LPAREN list(NEWLINE) . fun_args RPAREN [ LBRACKET DOT ]
## expr_term_paren -> IDENTIFIER LPAREN list(NEWLINE) . fun_args RPAREN [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER LPAREN list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression in function call, found symbol.

main: FALSE EQUAL LPAREN FALSE TRUE
##
## Ends in an error in state: 49.
##
## expr_term -> simple_expr . [ LBRACKET DOT ]
## expr_term_paren -> simple_expr . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## simple_expr
##

Expected operator or function call, found unexpected symbol.

main: FALSE EQUAL LPAREN NOT FALSE EQUAL
##
## Ends in an error in state: 50.
##
## expr_paren -> operation_paren . list(NEWLINE) [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## operation_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 240, spurious reduction of production unary_op -> NOT expr_term
## In state 48, spurious reduction of production operation_paren -> unary_op
##

Expected operator or function call, unexpected symbol.

main: FALSE EQUAL LPAREN IDENTIFIER LPAREN FALSE ELLIPSIS NEWLINE TRUE
##
## Ends in an error in state: 52.
##
## expr_term -> IDENTIFIER LPAREN list(NEWLINE) fun_args . RPAREN [ LBRACKET DOT ]
## expr_term_paren -> IDENTIFIER LPAREN list(NEWLINE) fun_args . RPAREN [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER LPAREN list(NEWLINE) fun_args
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 163, spurious reduction of production fun_args -> expr_paren ELLIPSIS list(NEWLINE)
##

Ellipsis operator only valid as less argument in function call.

main: FALSE EQUAL LPAREN IDENTIFIER LPAREN RPAREN TRUE
##
## Ends in an error in state: 53.
##
## expr_term -> IDENTIFIER LPAREN list(NEWLINE) fun_args RPAREN . [ LBRACKET DOT ]
## expr_term_paren -> IDENTIFIER LPAREN list(NEWLINE) fun_args RPAREN . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER LPAREN list(NEWLINE) fun_args RPAREN
##

Expected operator after function call, found unexpected symbol or expression.

main: FALSE EQUAL LPAREN FALSE LBRACKET RPAREN
##
## Ends in an error in state: 57.
##
## expr_term -> expr_term LBRACKET . MULT RBRACKET [ LBRACKET DOT ]
## expr_term -> expr_term LBRACKET . expr RBRACKET [ LBRACKET DOT ]
## expr_term_paren -> expr_term LBRACKET . MULT RBRACKET [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## expr_term_paren -> expr_term LBRACKET . expr RBRACKET [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term LBRACKET
##

Expected expression in index operator.

main: FALSE EQUAL LPAREN FALSE LBRACKET MULT TRUE
##
## Ends in an error in state: 58.
##
## expr_term -> expr_term LBRACKET MULT . RBRACKET [ LBRACKET DOT ]
## expr_term_paren -> expr_term LBRACKET MULT . RBRACKET [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term LBRACKET MULT
##

Unexpected expression found after splat operator, expected closing bracket.

main: FALSE EQUAL LPAREN FALSE LBRACKET MULT RBRACKET TRUE
##
## Ends in an error in state: 59.
##
## expr_term -> expr_term LBRACKET MULT RBRACKET . [ LBRACKET DOT ]
## expr_term_paren -> expr_term LBRACKET MULT RBRACKET . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term LBRACKET MULT RBRACKET
##

Unexpected expression found after index operator.

main: FALSE EQUAL FALSE RPAREN
##
## Ends in an error in state: 63.
##
## expr -> expr_term . [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## expr_term -> expr_term . LBRACKET MULT RBRACKET [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term . LBRACKET expr RBRACKET [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term . DOT IDENTIFIER [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term . DOT MULT [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term . DOT INTEGER [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term
##

Unexpected closing paranthesis found.

main: FALSE EQUAL FALSE LBRACKET RPAREN
##
## Ends in an error in state: 64.
##
## expr_term -> expr_term LBRACKET . MULT RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term LBRACKET . expr RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term LBRACKET
##

Expected expression in index operator, found symbol.

main: FALSE EQUAL FALSE LBRACKET MULT TRUE
##
## Ends in an error in state: 65.
##
## expr_term -> expr_term LBRACKET MULT . RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term LBRACKET MULT
##

Unexpected expression found after splat operator, expected closing bracket.

main: FALSE EQUAL FALSE LBRACKET FALSE RBRACE
##
## Ends in an error in state: 67.
##
## binary_op -> expr . PLUS expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . MINUS expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . MULT expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . DIV expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LOG_AND expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LOG_OR expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . PERCENT expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## expr_term -> expr_term LBRACKET expr . RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term LBRACKET expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
##

Unexpected closing brace.

main: FALSE EQUAL FALSE QUESTION_MARK RPAREN
##
## Ends in an error in state: 69.
##
## conditional -> expr QUESTION_MARK . expr COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr QUESTION_MARK
##

Expected expression in "then" clause of conditional.

main: FALSE EQUAL FALSE QUESTION_MARK FALSE RBRACKET
##
## Ends in an error in state: 70.
##
## binary_op -> expr . PLUS expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . MINUS expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . MULT expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . DIV expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . LESS_THAN expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . GREATER_THAN expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . IS_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . NOT_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . LOG_AND expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . LOG_OR expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . PERCENT expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## conditional -> expr QUESTION_MARK expr . COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr QUESTION_MARK expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
##

Unexpected symbol found in "then" clause of conditional.

main: FALSE EQUAL FALSE PLUS RPAREN
##
## Ends in an error in state: 71.
##
## binary_op -> expr PLUS . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr PLUS
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL FALSE PLUS NOT FALSE RPAREN
##
## Ends in an error in state: 72.
##
## binary_op -> expr . PLUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr PLUS expr . [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MINUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MULT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . DIV expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_AND expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_OR expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . PERCENT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr PLUS expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 240, spurious reduction of production unary_op -> NOT expr_term
## In state 60, spurious reduction of production operation -> unary_op
## In state 62, spurious reduction of production expr -> operation
##

Unexpected closing parenthesis found.

main: FALSE EQUAL FALSE PERCENT RPAREN
##
## Ends in an error in state: 73.
##
## binary_op -> expr PERCENT . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr PERCENT
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL FALSE MULT RPAREN
##
## Ends in an error in state: 78.
##
## binary_op -> expr MULT . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr MULT
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL FALSE DIV RPAREN
##
## Ends in an error in state: 80.
##
## binary_op -> expr DIV . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr DIV
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL FALSE NOT_EQUAL RPAREN
##
## Ends in an error in state: 82.
##
## binary_op -> expr NOT_EQUAL . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr NOT_EQUAL
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL FALSE NOT_EQUAL NOT FALSE RPAREN
##
## Ends in an error in state: 83.
##
## binary_op -> expr . PLUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MINUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MULT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . DIV expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr NOT_EQUAL expr . [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_AND expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_OR expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . PERCENT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr NOT_EQUAL expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 240, spurious reduction of production unary_op -> NOT expr_term
## In state 60, spurious reduction of production operation -> unary_op
## In state 62, spurious reduction of production expr -> operation
##

Unexpected closing parenthesis found.

main: FALSE EQUAL FALSE MINUS RPAREN
##
## Ends in an error in state: 84.
##
## binary_op -> expr MINUS . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr MINUS
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL FALSE MINUS NOT FALSE RPAREN
##
## Ends in an error in state: 85.
##
## binary_op -> expr . PLUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MINUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr MINUS expr . [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MULT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . DIV expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_AND expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_OR expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . PERCENT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr MINUS expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 240, spurious reduction of production unary_op -> NOT expr_term
## In state 60, spurious reduction of production operation -> unary_op
## In state 62, spurious reduction of production expr -> operation
##

Unexpected closing parenthesis found.

main: FALSE EQUAL FALSE LESS_THAN_EQUAL RPAREN
##
## Ends in an error in state: 86.
##
## binary_op -> expr LESS_THAN_EQUAL . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr LESS_THAN_EQUAL
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL FALSE LESS_THAN_EQUAL NOT FALSE RPAREN
##
## Ends in an error in state: 87.
##
## binary_op -> expr . PLUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MINUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MULT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . DIV expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr LESS_THAN_EQUAL expr . [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_AND expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_OR expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . PERCENT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr LESS_THAN_EQUAL expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 240, spurious reduction of production unary_op -> NOT expr_term
## In state 60, spurious reduction of production operation -> unary_op
## In state 62, spurious reduction of production expr -> operation
##

Unexpected closing parenthesis found.

main: FALSE EQUAL FALSE LESS_THAN RPAREN
##
## Ends in an error in state: 88.
##
## binary_op -> expr LESS_THAN . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr LESS_THAN
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL FALSE LESS_THAN NOT FALSE RPAREN
##
## Ends in an error in state: 89.
##
## binary_op -> expr . PLUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MINUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MULT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . DIV expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr LESS_THAN expr . [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_AND expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_OR expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . PERCENT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr LESS_THAN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 240, spurious reduction of production unary_op -> NOT expr_term
## In state 60, spurious reduction of production operation -> unary_op
## In state 62, spurious reduction of production expr -> operation
##

Unexpected closing parenthesis found.

main: FALSE EQUAL FALSE GREATER_THAN_EQUAL RPAREN
##
## Ends in an error in state: 90.
##
## binary_op -> expr GREATER_THAN_EQUAL . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr GREATER_THAN_EQUAL
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL FALSE GREATER_THAN_EQUAL NOT FALSE RPAREN
##
## Ends in an error in state: 91.
##
## binary_op -> expr . PLUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MINUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MULT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . DIV expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr GREATER_THAN_EQUAL expr . [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_AND expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_OR expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . PERCENT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr GREATER_THAN_EQUAL expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 240, spurious reduction of production unary_op -> NOT expr_term
## In state 60, spurious reduction of production operation -> unary_op
## In state 62, spurious reduction of production expr -> operation
##

Unexpected closing parenthesis found.

main: FALSE EQUAL FALSE GREATER_THAN RPAREN
##
## Ends in an error in state: 92.
##
## binary_op -> expr GREATER_THAN . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr GREATER_THAN
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL FALSE GREATER_THAN NOT FALSE RPAREN
##
## Ends in an error in state: 93.
##
## binary_op -> expr . PLUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MINUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MULT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . DIV expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr GREATER_THAN expr . [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_AND expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_OR expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . PERCENT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr GREATER_THAN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 240, spurious reduction of production unary_op -> NOT expr_term
## In state 60, spurious reduction of production operation -> unary_op
## In state 62, spurious reduction of production expr -> operation
##

Unexpected closing parenthesis found.

main: FALSE EQUAL FALSE LOG_OR RPAREN
##
## Ends in an error in state: 94.
##
## binary_op -> expr LOG_OR . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr LOG_OR
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL FALSE LOG_OR NOT FALSE RPAREN
##
## Ends in an error in state: 95.
##
## binary_op -> expr . PLUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MINUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MULT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . DIV expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_AND expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_OR expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr LOG_OR expr . [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . PERCENT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr LOG_OR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 240, spurious reduction of production unary_op -> NOT expr_term
## In state 60, spurious reduction of production operation -> unary_op
## In state 62, spurious reduction of production expr -> operation
##

Unexpected closing parenthesis found.

main: FALSE EQUAL FALSE LOG_AND RPAREN
##
## Ends in an error in state: 96.
##
## binary_op -> expr LOG_AND . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr LOG_AND
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL FALSE LOG_AND NOT FALSE RPAREN
##
## Ends in an error in state: 97.
##
## binary_op -> expr . PLUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MINUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MULT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . DIV expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_AND expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr LOG_AND expr . [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_OR expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . PERCENT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr LOG_AND expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 240, spurious reduction of production unary_op -> NOT expr_term
## In state 60, spurious reduction of production operation -> unary_op
## In state 62, spurious reduction of production expr -> operation
##

Unexpected closing parenthesis found.

main: FALSE EQUAL FALSE IS_EQUAL RPAREN
##
## Ends in an error in state: 98.
##
## binary_op -> expr IS_EQUAL . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr IS_EQUAL
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL FALSE IS_EQUAL NOT FALSE RPAREN
##
## Ends in an error in state: 99.
##
## binary_op -> expr . PLUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MINUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MULT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . DIV expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr IS_EQUAL expr . [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_AND expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_OR expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . PERCENT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr IS_EQUAL expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 240, spurious reduction of production unary_op -> NOT expr_term
## In state 60, spurious reduction of production operation -> unary_op
## In state 62, spurious reduction of production expr -> operation
##

Unexpected closing parenthesis found.

main: FALSE EQUAL FALSE QUESTION_MARK FALSE COLON RPAREN
##
## Ends in an error in state: 100.
##
## conditional -> expr QUESTION_MARK expr COLON . expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr QUESTION_MARK expr COLON
##

Expected expression in "else" clause of conditional.

main: FALSE EQUAL FALSE QUESTION_MARK FALSE COLON NOT FALSE RPAREN
##
## Ends in an error in state: 101.
##
## binary_op -> expr . PLUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MINUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . MULT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . DIV expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_AND expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . LOG_OR expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## binary_op -> expr . PERCENT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
## conditional -> expr QUESTION_MARK expr COLON expr . [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr QUESTION_MARK expr COLON expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 240, spurious reduction of production unary_op -> NOT expr_term
## In state 60, spurious reduction of production operation -> unary_op
## In state 62, spurious reduction of production expr -> operation
##

Unexpected closing parenthesis found.

main: FALSE EQUAL FALSE DOT TRUE
##
## Ends in an error in state: 102.
##
## expr_term -> expr_term DOT . IDENTIFIER [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term DOT . MULT [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term DOT . INTEGER [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term DOT
##

Identifier or integer expected as attribute to object.

main: FALSE EQUAL LPAREN FALSE LBRACKET FALSE RBRACE
##
## Ends in an error in state: 106.
##
## binary_op -> expr . PLUS expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . MINUS expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . MULT expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . DIV expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LOG_AND expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LOG_OR expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . PERCENT expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## expr_term -> expr_term LBRACKET expr . RBRACKET [ LBRACKET DOT ]
## expr_term_paren -> expr_term LBRACKET expr . RBRACKET [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term LBRACKET expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
##

Unexpected closing brace found.

main: FALSE EQUAL LPAREN FALSE LBRACKET FALSE RBRACKET TRUE
##
## Ends in an error in state: 107.
##
## expr_term -> expr_term LBRACKET expr RBRACKET . [ LBRACKET DOT ]
## expr_term_paren -> expr_term LBRACKET expr RBRACKET . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term LBRACKET expr RBRACKET
##

Unexpected expression found after index operator.

main: FALSE EQUAL LPAREN FALSE DOT TRUE
##
## Ends in an error in state: 108.
##
## expr_term -> expr_term DOT . IDENTIFIER [ LBRACKET DOT ]
## expr_term -> expr_term DOT . MULT [ LBRACKET DOT ]
## expr_term -> expr_term DOT . INTEGER [ LBRACKET DOT ]
## expr_term_paren -> expr_term DOT . IDENTIFIER [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## expr_term_paren -> expr_term DOT . MULT [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## expr_term_paren -> expr_term DOT . INTEGER [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term DOT
##

Identifier or integer expected as attribute to object.

main: FALSE EQUAL LPAREN FALSE DOT MULT TRUE
##
## Ends in an error in state: 109.
##
## expr_term -> expr_term DOT MULT . [ LBRACKET DOT ]
## expr_term_paren -> expr_term DOT MULT . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term DOT MULT
##

Unexpected expression found after splat operator, expected closing bracket.

main: FALSE EQUAL LPAREN FALSE DOT INTEGER TRUE
##
## Ends in an error in state: 110.
##
## expr_term -> expr_term DOT INTEGER . [ LBRACKET DOT ]
## expr_term_paren -> expr_term DOT INTEGER . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term DOT INTEGER
##

Expected operator, found expression.

main: FALSE EQUAL LPAREN FALSE DOT IDENTIFIER TRUE
##
## Ends in an error in state: 111.
##
## expr_term -> expr_term DOT IDENTIFIER . [ LBRACKET DOT ]
## expr_term_paren -> expr_term DOT IDENTIFIER . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_term DOT IDENTIFIER
##

Expected operator, found expression.

main: FALSE EQUAL IDENTIFIER LPAREN FALSE COLON
##
## Ends in an error in state: 112.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## fun_args -> expr_paren . ELLIPSIS list(NEWLINE) [ RPAREN ]
## fun_args -> expr_paren . list(NEWLINE) [ RPAREN ]
## fun_args -> expr_paren . COMMA list(NEWLINE) fun_args [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 49, spurious reduction of production expr_term_paren -> simple_expr
## In state 54, spurious reduction of production list(NEWLINE) ->
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Unexpected colon.

main: FALSE EQUAL LPAREN FALSE QUESTION_MARK RPAREN
##
## Ends in an error in state: 113.
##
## conditional_paren -> expr_paren QUESTION_MARK . list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren QUESTION_MARK
##

Unexpected symbol found in "then" clause of conditional.

main: FALSE EQUAL LPAREN FALSE QUESTION_MARK NEWLINE RPAREN
##
## Ends in an error in state: 114.
##
## conditional_paren -> expr_paren QUESTION_MARK list(NEWLINE) . expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren QUESTION_MARK list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Unexpected symbol found in "then" clause of conditional.

main: FALSE EQUAL LPAREN FALSE QUESTION_MARK FALSE RPAREN
##
## Ends in an error in state: 115.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## conditional_paren -> expr_paren QUESTION_MARK list(NEWLINE) expr_paren . COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren QUESTION_MARK list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 49, spurious reduction of production expr_term_paren -> simple_expr
## In state 54, spurious reduction of production list(NEWLINE) ->
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Premature termination of condition.

main: FALSE EQUAL LPAREN FALSE PLUS RPAREN
##
## Ends in an error in state: 116.
##
## binary_op_paren -> expr_paren PLUS . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren PLUS
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE PLUS NEWLINE RPAREN
##
## Ends in an error in state: 117.
##
## binary_op_paren -> expr_paren PLUS list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren PLUS list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE PLUS FALSE NEWLINE TRUE
##
## Ends in an error in state: 118.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren PLUS list(NEWLINE) expr_paren . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren PLUS list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Expected operator, found expression.

main: FALSE EQUAL LPAREN FALSE PERCENT RPAREN
##
## Ends in an error in state: 119.
##
## binary_op_paren -> expr_paren PERCENT . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren PERCENT
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE PERCENT NEWLINE RPAREN
##
## Ends in an error in state: 120.
##
## binary_op_paren -> expr_paren PERCENT list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren PERCENT list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN LBRACKET RBRACKET TRUE
##
## Ends in an error in state: 124.
##
## expr_term -> collection_expr . [ LBRACKET DOT ]
## expr_term_paren -> collection_expr . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## collection_expr
##

Expected operator, found expression.

main: FALSE EQUAL LPAREN FALSE MULT RPAREN
##
## Ends in an error in state: 126.
##
## binary_op_paren -> expr_paren MULT . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren MULT
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE MULT NEWLINE RPAREN
##
## Ends in an error in state: 127.
##
## binary_op_paren -> expr_paren MULT list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren MULT list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE DIV RPAREN
##
## Ends in an error in state: 129.
##
## binary_op_paren -> expr_paren DIV . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren DIV
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE DIV NEWLINE RPAREN
##
## Ends in an error in state: 130.
##
## binary_op_paren -> expr_paren DIV list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren DIV list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE NOT_EQUAL RPAREN
##
## Ends in an error in state: 132.
##
## binary_op_paren -> expr_paren NOT_EQUAL . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren NOT_EQUAL
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE NOT_EQUAL NEWLINE RPAREN
##
## Ends in an error in state: 133.
##
## binary_op_paren -> expr_paren NOT_EQUAL list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren NOT_EQUAL list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE NOT_EQUAL FALSE NEWLINE TRUE
##
## Ends in an error in state: 134.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren NOT_EQUAL list(NEWLINE) expr_paren . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren NOT_EQUAL list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Expected operator, found expression.

main: FALSE EQUAL LPAREN FALSE MINUS RPAREN
##
## Ends in an error in state: 135.
##
## binary_op_paren -> expr_paren MINUS . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren MINUS
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE MINUS NEWLINE RPAREN
##
## Ends in an error in state: 136.
##
## binary_op_paren -> expr_paren MINUS list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren MINUS list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE MINUS FALSE NEWLINE TRUE
##
## Ends in an error in state: 137.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren MINUS list(NEWLINE) expr_paren . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren MINUS list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Expected operator, found expression.

main: FALSE EQUAL LPAREN FALSE LESS_THAN_EQUAL RPAREN
##
## Ends in an error in state: 138.
##
## binary_op_paren -> expr_paren LESS_THAN_EQUAL . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren LESS_THAN_EQUAL
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE LESS_THAN_EQUAL NEWLINE RPAREN
##
## Ends in an error in state: 139.
##
## binary_op_paren -> expr_paren LESS_THAN_EQUAL list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren LESS_THAN_EQUAL list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE LESS_THAN_EQUAL FALSE NEWLINE TRUE
##
## Ends in an error in state: 140.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren LESS_THAN_EQUAL list(NEWLINE) expr_paren . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren LESS_THAN_EQUAL list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Expected operator, found expression.

main: FALSE EQUAL LPAREN FALSE LESS_THAN RPAREN
##
## Ends in an error in state: 141.
##
## binary_op_paren -> expr_paren LESS_THAN . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren LESS_THAN
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE LESS_THAN NEWLINE RPAREN
##
## Ends in an error in state: 142.
##
## binary_op_paren -> expr_paren LESS_THAN list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren LESS_THAN list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE LESS_THAN FALSE NEWLINE TRUE
##
## Ends in an error in state: 143.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren LESS_THAN list(NEWLINE) expr_paren . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren LESS_THAN list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Expected operator, found expression.

main: FALSE EQUAL LPAREN FALSE GREATER_THAN_EQUAL RPAREN
##
## Ends in an error in state: 144.
##
## binary_op_paren -> expr_paren GREATER_THAN_EQUAL . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren GREATER_THAN_EQUAL
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE GREATER_THAN_EQUAL NEWLINE RPAREN
##
## Ends in an error in state: 145.
##
## binary_op_paren -> expr_paren GREATER_THAN_EQUAL list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren GREATER_THAN_EQUAL list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE GREATER_THAN_EQUAL FALSE NEWLINE TRUE
##
## Ends in an error in state: 146.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren GREATER_THAN_EQUAL list(NEWLINE) expr_paren . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren GREATER_THAN_EQUAL list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Expected operator, found expression.

main: FALSE EQUAL LPAREN FALSE GREATER_THAN RPAREN
##
## Ends in an error in state: 147.
##
## binary_op_paren -> expr_paren GREATER_THAN . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren GREATER_THAN
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE GREATER_THAN NEWLINE RPAREN
##
## Ends in an error in state: 148.
##
## binary_op_paren -> expr_paren GREATER_THAN list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren GREATER_THAN list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE GREATER_THAN FALSE NEWLINE TRUE
##
## Ends in an error in state: 149.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren GREATER_THAN list(NEWLINE) expr_paren . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren GREATER_THAN list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Expected operator, found expression.

main: FALSE EQUAL LPAREN FALSE LOG_OR RPAREN
##
## Ends in an error in state: 150.
##
## binary_op_paren -> expr_paren LOG_OR . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren LOG_OR
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE LOG_OR NEWLINE RPAREN
##
## Ends in an error in state: 151.
##
## binary_op_paren -> expr_paren LOG_OR list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren LOG_OR list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE LOG_OR FALSE NEWLINE TRUE
##
## Ends in an error in state: 152.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren LOG_OR list(NEWLINE) expr_paren . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren LOG_OR list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Expected operator, found expression.

main: FALSE EQUAL LPAREN FALSE LOG_AND RPAREN
##
## Ends in an error in state: 153.
##
## binary_op_paren -> expr_paren LOG_AND . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren LOG_AND
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE LOG_AND NEWLINE RPAREN
##
## Ends in an error in state: 154.
##
## binary_op_paren -> expr_paren LOG_AND list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren LOG_AND list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE LOG_AND FALSE NEWLINE TRUE
##
## Ends in an error in state: 155.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren LOG_AND list(NEWLINE) expr_paren . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren LOG_AND list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Expected operator, found expression.

main: FALSE EQUAL LPAREN FALSE IS_EQUAL RPAREN
##
## Ends in an error in state: 156.
##
## binary_op_paren -> expr_paren IS_EQUAL . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren IS_EQUAL
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE IS_EQUAL NEWLINE RPAREN
##
## Ends in an error in state: 157.
##
## binary_op_paren -> expr_paren IS_EQUAL list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren IS_EQUAL list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected second operand in binary operator, found symbol.

main: FALSE EQUAL LPAREN FALSE IS_EQUAL FALSE NEWLINE TRUE
##
## Ends in an error in state: 158.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren IS_EQUAL list(NEWLINE) expr_paren . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren IS_EQUAL list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Expected operator, found expression.

main: FALSE EQUAL LPAREN FALSE QUESTION_MARK FALSE COLON RPAREN
##
## Ends in an error in state: 159.
##
## conditional_paren -> expr_paren QUESTION_MARK list(NEWLINE) expr_paren COLON . list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren QUESTION_MARK list(NEWLINE) expr_paren COLON
##

Expected expression in "else" clause of conditional.

main: FALSE EQUAL LPAREN FALSE QUESTION_MARK FALSE COLON NEWLINE RPAREN
##
## Ends in an error in state: 160.
##
## conditional_paren -> expr_paren QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) . expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression in "else" clause of conditional.

main: FALSE EQUAL LPAREN FALSE QUESTION_MARK FALSE COLON FALSE NEWLINE TRUE
##
## Ends in an error in state: 161.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
## conditional_paren -> expr_paren QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr_paren QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Expected operator in "else" clause of conditional but found expression.

main: FALSE EQUAL IDENTIFIER LPAREN FALSE ELLIPSIS TRUE
##
## Ends in an error in state: 162.
##
## fun_args -> expr_paren ELLIPSIS . list(NEWLINE) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr_paren ELLIPSIS
##

Ellipsis operator only valid as less argument in function call.

main: FALSE EQUAL IDENTIFIER LPAREN FALSE COMMA RBRACKET
##
## Ends in an error in state: 164.
##
## fun_args -> expr_paren COMMA . list(NEWLINE) fun_args [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr_paren COMMA
##

Expected expression for function argument, found symbol.

main: FALSE EQUAL IDENTIFIER LPAREN FALSE COMMA NEWLINE RBRACKET
##
## Ends in an error in state: 165.
##
## fun_args -> expr_paren COMMA list(NEWLINE) . fun_args [ RPAREN ]
##
## The known suffix of the stack is as follows:
## expr_paren COMMA list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression for function argument, found symbol.

main: FALSE EQUAL LPAREN LPAREN FALSE ELLIPSIS
##
## Ends in an error in state: 168.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## expr_term -> LPAREN list(NEWLINE) expr_paren . RPAREN [ LBRACKET DOT ]
## expr_term_paren -> LPAREN list(NEWLINE) expr_paren . RPAREN [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 49, spurious reduction of production expr_term_paren -> simple_expr
## In state 54, spurious reduction of production list(NEWLINE) ->
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Invalid usafe of ellipsis.

main: FALSE EQUAL LPAREN LPAREN FALSE RPAREN TRUE
##
## Ends in an error in state: 169.
##
## expr_term -> LPAREN list(NEWLINE) expr_paren RPAREN . [ LBRACKET DOT ]
## expr_term_paren -> LPAREN list(NEWLINE) expr_paren RPAREN . [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN list(NEWLINE) expr_paren RPAREN
##

Expected operator, found expression.

main: FALSE EQUAL IDENTIFIER LPAREN FALSE ELLIPSIS NEWLINE TRUE
##
## Ends in an error in state: 170.
##
## expr_term -> IDENTIFIER LPAREN list(NEWLINE) fun_args . RPAREN [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER LPAREN list(NEWLINE) fun_args
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 163, spurious reduction of production fun_args -> expr_paren ELLIPSIS list(NEWLINE)
##

Ellipsis operator only valid as less argument in function call.

main: FALSE EQUAL LBRACE FOR TRUE
##
## Ends in an error in state: 172.
##
## collection_expr -> LBRACE list(NEWLINE) FOR . list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR
##

Identifier required in "for" expression.

main: FALSE EQUAL LBRACE FOR NEWLINE TRUE
##
## Ends in an error in state: 173.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) . IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Identifier required in "for" expression, expression found.

main: FALSE EQUAL LBRACE FOR IDENTIFIER TRUE
##
## Ends in an error in state: 174.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER . identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER
##

Comma required between multiple identifiers in "for".

main: FALSE EQUAL LBRACE FOR IDENTIFIER COMMA TRUE
##
## Ends in an error in state: 175.
##
## identifiers_rest -> COMMA . IDENTIFIER identifiers_rest [ NEWLINE IN ]
##
## The known suffix of the stack is as follows:
## COMMA
##

Identifier required in "for" expression, expression found.

main: FALSE EQUAL LBRACE FOR IDENTIFIER COMMA IDENTIFIER TRUE
##
## Ends in an error in state: 176.
##
## identifiers_rest -> COMMA IDENTIFIER . identifiers_rest [ NEWLINE IN ]
##
## The known suffix of the stack is as follows:
## COMMA IDENTIFIER
##

Comma required between multiple identifiers in "for".

main: FALSE EQUAL LBRACE FOR IDENTIFIER NEWLINE TRUE
##
## Ends in an error in state: 179.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) . IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Comma required between multiple identifiers in "for".

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN RPAREN
##
## Ends in an error in state: 180.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN . list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN
##

Expected expression in "in" clause of "for", found symbol.

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN NEWLINE RPAREN
##
## Ends in an error in state: 181.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) . expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression in "in" clause of "for", found symbol.

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN FALSE RBRACKET
##
## Ends in an error in state: 182.
##
## binary_op -> expr . PLUS expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . MINUS expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . MULT expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . DIV expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . LESS_THAN expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . GREATER_THAN expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . IS_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . NOT_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . LOG_AND expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . LOG_OR expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . PERCENT expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr . list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
##

Unexpected closing bracket.

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN FALSE NEWLINE TRUE
##
## Ends in an error in state: 183.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) . COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected operator in "in" clause of "for", found expression.

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN FALSE COLON RPAREN
##
## Ends in an error in state: 184.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON . list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON
##

Expected expression in "value" clause of "for", found symbol.

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN FALSE COLON NEWLINE RPAREN
##
## Ends in an error in state: 185.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) . expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression in "value" clause of "for", found symbol.

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN FALSE COLON FALSE RBRACKET
##
## Ends in an error in state: 186.
##
## binary_op -> expr . PLUS expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
## binary_op -> expr . MINUS expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
## binary_op -> expr . MULT expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
## binary_op -> expr . DIV expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
## binary_op -> expr . LESS_THAN expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
## binary_op -> expr . GREATER_THAN expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
## binary_op -> expr . IS_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
## binary_op -> expr . NOT_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
## binary_op -> expr . LOG_AND expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
## binary_op -> expr . LOG_OR expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
## binary_op -> expr . PERCENT expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr . list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW DIV ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
##

Expected key-value pair in "value" clause in "for".

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN FALSE COLON FALSE NEWLINE TRUE
##
## Ends in an error in state: 187.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) . FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected operator in "value" clause of "for", found expression.

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN FALSE COLON FALSE FAT_ARROW RPAREN
##
## Ends in an error in state: 188.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW . list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW
##

Expected expression in value section of key-value pair in "value" clause of "for".

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN FALSE COLON FALSE FAT_ARROW NEWLINE RPAREN
##
## Ends in an error in state: 189.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) . for_obj_value list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression in value section of key-value pair in "value" clause of "for".

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN FALSE COLON FALSE FAT_ARROW FALSE ELLIPSIS TRUE
##
## Ends in an error in state: 190.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value . list(NEWLINE) option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value
##

Ellipsis operator only valid as last part of expression in "for".

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN FALSE COLON FALSE FAT_ARROW FALSE NEWLINE TRUE
##
## Ends in an error in state: 191.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) . option(collection_if) RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected operator in value portion of key-value pair in "value" close of "for", found expression.

main: FALSE EQUAL LBRACKET FOR IDENTIFIER IN FALSE COLON FALSE IF RPAREN
##
## Ends in an error in state: 192.
##
## option(collection_if) -> IF . list(NEWLINE) expr list(NEWLINE) [ RBRACKET RBRACE ]
##
## The known suffix of the stack is as follows:
## IF
##

Expected expression in "if" clause of "for", found symbol.

main: FALSE EQUAL LBRACKET FOR IDENTIFIER IN FALSE COLON FALSE IF NEWLINE RPAREN
##
## Ends in an error in state: 193.
##
## option(collection_if) -> IF list(NEWLINE) . expr list(NEWLINE) [ RBRACKET RBRACE ]
##
## The known suffix of the stack is as follows:
## IF list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression in "if" clause of "for", found symbol.

main: FALSE EQUAL LBRACKET FOR IDENTIFIER IN FALSE COLON FALSE IF FALSE IF
##
## Ends in an error in state: 194.
##
## binary_op -> expr . PLUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . MINUS expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . MULT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . DIV expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LOG_AND expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LOG_OR expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . PERCENT expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## option(collection_if) -> IF list(NEWLINE) expr . list(NEWLINE) [ RBRACKET RBRACE ]
##
## The known suffix of the stack is as follows:
## IF list(NEWLINE) expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
##

Unexpected operator in "if" clause of "for".

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN FALSE COLON FALSE FAT_ARROW FALSE IF FALSE RBRACKET
##
## Ends in an error in state: 196.
##
## collection_expr -> LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if) . RBRACE [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) FAT_ARROW list(NEWLINE) for_obj_value list(NEWLINE) option(collection_if)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
## In state 194, spurious reduction of production list(NEWLINE) ->
## In state 195, spurious reduction of production option(collection_if) -> IF list(NEWLINE) expr list(NEWLINE)
##

Unexpected closing bracket.

main: FALSE EQUAL LBRACE FOR IDENTIFIER IN FALSE COLON FALSE FAT_ARROW FALSE RBRACKET
##
## Ends in an error in state: 198.
##
## binary_op -> expr . PLUS expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## binary_op -> expr . MINUS expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## binary_op -> expr . MULT expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## binary_op -> expr . DIV expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## binary_op -> expr . LESS_THAN expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## binary_op -> expr . GREATER_THAN expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## binary_op -> expr . IS_EQUAL expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## binary_op -> expr . LOG_AND expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## binary_op -> expr . LOG_OR expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## binary_op -> expr . PERCENT expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV ]
## for_obj_value -> expr . [ RBRACE NEWLINE IF ]
## for_obj_value -> expr . ELLIPSIS [ RBRACE NEWLINE IF ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
##

Unexpected closing bracket.

main: FALSE EQUAL LBRACE IN TRUE
##
## Ends in an error in state: 200.
##
## obj -> obj_k . kv_sep expr [ RBRACE ]
## obj -> obj_k . kv_sep expr COMMA list(NEWLINE) obj [ RBRACE ]
## obj -> obj_k . kv_sep expr nonempty_list(NEWLINE) obj [ RBRACE ]
##
## The known suffix of the stack is as follows:
## obj_k
##

Expected "value" portion of object key-value pair.

main: FALSE EQUAL LBRACE FALSE COLON RPAREN
##
## Ends in an error in state: 203.
##
## obj -> obj_k kv_sep . expr [ RBRACE ]
## obj -> obj_k kv_sep . expr COMMA list(NEWLINE) obj [ RBRACE ]
## obj -> obj_k kv_sep . expr nonempty_list(NEWLINE) obj [ RBRACE ]
##
## The known suffix of the stack is as follows:
## obj_k kv_sep
##

Expected expression in "value" portion of key-value pair, found symbol.

main: FALSE EQUAL LBRACE FALSE COLON FALSE RBRACKET
##
## Ends in an error in state: 204.
##
## binary_op -> expr . PLUS expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## binary_op -> expr . MINUS expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## binary_op -> expr . MULT expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## binary_op -> expr . DIV expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## binary_op -> expr . LESS_THAN expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## binary_op -> expr . GREATER_THAN expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## binary_op -> expr . IS_EQUAL expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## binary_op -> expr . LOG_AND expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## binary_op -> expr . LOG_OR expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## binary_op -> expr . PERCENT expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COMMA ]
## obj -> obj_k kv_sep expr . [ RBRACE ]
## obj -> obj_k kv_sep expr . COMMA list(NEWLINE) obj [ RBRACE ]
## obj -> obj_k kv_sep expr . nonempty_list(NEWLINE) obj [ RBRACE ]
##
## The known suffix of the stack is as follows:
## obj_k kv_sep expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
##

Unexpected closing bracket.

main: FALSE EQUAL LBRACE FALSE COLON FALSE COMMA RPAREN
##
## Ends in an error in state: 205.
##
## obj -> obj_k kv_sep expr COMMA . list(NEWLINE) obj [ RBRACE ]
##
## The known suffix of the stack is as follows:
## obj_k kv_sep expr COMMA
##

Expected key-value expression, found symbol.

main: FALSE EQUAL LBRACE FALSE COLON FALSE COMMA NEWLINE RPAREN
##
## Ends in an error in state: 206.
##
## obj -> obj_k kv_sep expr COMMA list(NEWLINE) . obj [ RBRACE ]
##
## The known suffix of the stack is as follows:
## obj_k kv_sep expr COMMA list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected key-value expression, found symbol.

main: FALSE EQUAL LBRACE FALSE RBRACKET
##
## Ends in an error in state: 208.
##
## binary_op -> expr . PLUS expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## binary_op -> expr . MINUS expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## binary_op -> expr . MULT expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## binary_op -> expr . DIV expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## binary_op -> expr . LESS_THAN expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## binary_op -> expr . GREATER_THAN expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## binary_op -> expr . IS_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## binary_op -> expr . NOT_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## binary_op -> expr . LOG_AND expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## binary_op -> expr . LOG_OR expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## binary_op -> expr . PERCENT expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN EQUAL DIV COLON ]
## obj_k -> expr . [ EQUAL COLON ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
##

Unexpected closing bracket.

main: FALSE EQUAL LBRACE FALSE COLON FALSE NEWLINE EOF
##
## Ends in an error in state: 209.
##
## obj -> obj_k kv_sep expr nonempty_list(NEWLINE) . obj [ RBRACE ]
##
## The known suffix of the stack is as follows:
## obj_k kv_sep expr nonempty_list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 15, spurious reduction of production nonempty_list(NEWLINE) -> NEWLINE
##

Premature end of file.

main: FALSE EQUAL LBRACKET FOR TRUE
##
## Ends in an error in state: 213.
##
## collection_expr -> LBRACKET list(NEWLINE) FOR . list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) FOR
##

Identifier required in "for" expression.

main: FALSE EQUAL LBRACKET FOR NEWLINE TRUE
##
## Ends in an error in state: 214.
##
## collection_expr -> LBRACKET list(NEWLINE) FOR list(NEWLINE) . IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) FOR list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Identifier required in "for" expression, expression found.

main: FALSE EQUAL LBRACKET FOR IDENTIFIER TRUE
##
## Ends in an error in state: 215.
##
## collection_expr -> LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER . identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER
##

Comma required between multiple identifiers in "for".

main: FALSE EQUAL LBRACKET FOR IDENTIFIER NEWLINE TRUE
##
## Ends in an error in state: 217.
##
## collection_expr -> LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) . IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Comma required between multiple identifiers in "for".

main: FALSE EQUAL LBRACKET FOR IDENTIFIER IN RPAREN
##
## Ends in an error in state: 218.
##
## collection_expr -> LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN . list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN
##

Expected expression in "in" clause of "for", found symbol.

main: FALSE EQUAL LBRACKET FOR IDENTIFIER IN NEWLINE RPAREN
##
## Ends in an error in state: 219.
##
## collection_expr -> LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) . expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression in "in" clause of "for", found symbol.

main: FALSE EQUAL LBRACKET FOR IDENTIFIER IN FALSE RBRACKET
##
## Ends in an error in state: 220.
##
## binary_op -> expr . PLUS expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . MINUS expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . MULT expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . DIV expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . LESS_THAN expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . GREATER_THAN expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . IS_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . NOT_EQUAL expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . LOG_AND expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . LOG_OR expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## binary_op -> expr . PERCENT expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
## collection_expr -> LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr . list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
##

Unexpected closing bracket.

main: FALSE EQUAL LBRACKET FOR IDENTIFIER IN FALSE NEWLINE TRUE
##
## Ends in an error in state: 221.
##
## collection_expr -> LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) . COLON list(NEWLINE) expr list(NEWLINE) option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected operator in "in" clause of "for", found expression.

main: FALSE EQUAL LBRACKET FOR IDENTIFIER IN FALSE COLON RPAREN
##
## Ends in an error in state: 222.
##
## collection_expr -> LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON . list(NEWLINE) expr list(NEWLINE) option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON
##

Expected expression in "value" clause of "for", found symbol.

main: FALSE EQUAL LBRACKET FOR IDENTIFIER IN FALSE COLON NEWLINE RPAREN
##
## Ends in an error in state: 223.
##
## collection_expr -> LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) . expr list(NEWLINE) option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression in "value" clause of "for", found symbol.

main: FALSE EQUAL LBRACKET FOR IDENTIFIER IN FALSE COLON FALSE RBRACE
##
## Ends in an error in state: 224.
##
## binary_op -> expr . PLUS expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . MINUS expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . MULT expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . DIV expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LOG_AND expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LOG_OR expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . PERCENT expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
## collection_expr -> LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr . list(NEWLINE) option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN DIV ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
##

Unexpected closing brace.

main: FALSE EQUAL LBRACKET FOR IDENTIFIER IN FALSE COLON FALSE NEWLINE TRUE
##
## Ends in an error in state: 225.
##
## collection_expr -> LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) . option(collection_if) RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected operator, found expression.

main: FALSE EQUAL LBRACKET FOR IDENTIFIER IN FALSE COLON FALSE IF FALSE RBRACE
##
## Ends in an error in state: 226.
##
## collection_expr -> LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) option(collection_if) . RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) FOR list(NEWLINE) IDENTIFIER identifiers_rest list(NEWLINE) IN list(NEWLINE) expr list(NEWLINE) COLON list(NEWLINE) expr list(NEWLINE) option(collection_if)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
## In state 194, spurious reduction of production list(NEWLINE) ->
## In state 195, spurious reduction of production option(collection_if) -> IF list(NEWLINE) expr list(NEWLINE)
##

Unexpected closing brace.

main: FALSE EQUAL LBRACKET FALSE ELLIPSIS NEWLINE TRUE
##
## Ends in an error in state: 228.
##
## collection_expr -> LBRACKET list(NEWLINE) tuple . RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET list(NEWLINE) tuple
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
## In state 232, spurious reduction of production tuple -> expr ELLIPSIS list(NEWLINE)
##

Ellipsis operator only valid as last element of tuple.

main: FALSE EQUAL LBRACKET FALSE RBRACE
##
## Ends in an error in state: 230.
##
## binary_op -> expr . PLUS expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op -> expr . MINUS expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op -> expr . MULT expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op -> expr . DIV expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op -> expr . LESS_THAN expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op -> expr . GREATER_THAN expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op -> expr . IS_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op -> expr . LOG_AND expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op -> expr . LOG_OR expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## binary_op -> expr . PERCENT expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACKET QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN ELLIPSIS DIV COMMA ]
## tuple -> expr . ELLIPSIS list(NEWLINE) [ RBRACKET ]
## tuple -> expr . list(NEWLINE) [ RBRACKET ]
## tuple -> expr . list(NEWLINE) COMMA list(NEWLINE) tuple [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
##

Unexpected closing brace found.

main: FALSE EQUAL LBRACKET FALSE ELLIPSIS TRUE
##
## Ends in an error in state: 231.
##
## tuple -> expr ELLIPSIS . list(NEWLINE) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr ELLIPSIS
##

Ellipsis operator only valid as last element of tuple.

main: FALSE EQUAL LBRACKET FALSE NEWLINE TRUE
##
## Ends in an error in state: 233.
##
## tuple -> expr list(NEWLINE) . [ RBRACKET ]
## tuple -> expr list(NEWLINE) . COMMA list(NEWLINE) tuple [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected operator, found expression.

main: FALSE EQUAL LBRACKET FALSE COMMA RPAREN
##
## Ends in an error in state: 234.
##
## tuple -> expr list(NEWLINE) COMMA . list(NEWLINE) tuple [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr list(NEWLINE) COMMA
##

Expected expression for function argument, found symbol.

main: FALSE EQUAL LBRACKET FALSE COMMA NEWLINE RPAREN
##
## Ends in an error in state: 235.
##
## tuple -> expr list(NEWLINE) COMMA list(NEWLINE) . tuple [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr list(NEWLINE) COMMA list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1, spurious reduction of production list(NEWLINE) ->
## In state 2, spurious reduction of production list(NEWLINE) -> NEWLINE list(NEWLINE)
##

Expected expression for function argument, found symbol.

main: FALSE EQUAL MINUS FALSE TRUE
##
## Ends in an error in state: 237.
##
## expr_term -> expr_term . LBRACKET MULT RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term . LBRACKET expr RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term . DOT IDENTIFIER [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term . DOT MULT [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term . DOT INTEGER [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## unary_op -> MINUS expr_term . [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## MINUS expr_term
##

Expected operator after unary operation, found expression.

main: FALSE EQUAL LPAREN FALSE ELLIPSIS
##
## Ends in an error in state: 238.
##
## binary_op_paren -> expr_paren . PLUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . MINUS list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . MULT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . DIV list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . LESS_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . LESS_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . GREATER_THAN list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . GREATER_THAN_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . IS_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . NOT_EQUAL list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . LOG_AND list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . LOG_OR list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op_paren -> expr_paren . PERCENT list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## conditional_paren -> expr_paren . QUESTION_MARK list(NEWLINE) expr_paren COLON list(NEWLINE) expr_paren [ RPAREN QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## expr_term -> LPAREN list(NEWLINE) expr_paren . RPAREN [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN list(NEWLINE) expr_paren
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 49, spurious reduction of production expr_term_paren -> simple_expr
## In state 54, spurious reduction of production list(NEWLINE) ->
## In state 55, spurious reduction of production expr_paren -> expr_term_paren list(NEWLINE)
##

Ellipsis operator not valid here.

main: FALSE EQUAL NOT FALSE TRUE
##
## Ends in an error in state: 240.
##
## expr_term -> expr_term . LBRACKET MULT RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term . LBRACKET expr RBRACKET [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term . DOT IDENTIFIER [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term . DOT MULT [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## expr_term -> expr_term . DOT INTEGER [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN LBRACKET IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DOT DIV COMMA COLON ]
## unary_op -> NOT expr_term . [ RPAREN RBRACKET RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL IF GREATER_THAN_EQUAL GREATER_THAN FAT_ARROW EQUAL ELLIPSIS DIV COMMA COLON ]
##
## The known suffix of the stack is as follows:
## NOT expr_term
##

Expected operator after unary operation, found expression.

main: FALSE EQUAL FALSE RBRACKET
##
## Ends in an error in state: 241.
##
## attribute -> identifier EQUAL expr . [ RBRACE NEWLINE ]
## binary_op -> expr . PLUS expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . MINUS expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . MULT expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . DIV expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LESS_THAN expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LESS_THAN_EQUAL expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . GREATER_THAN expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . GREATER_THAN_EQUAL expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . IS_EQUAL expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . NOT_EQUAL expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LOG_AND expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . LOG_OR expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## binary_op -> expr . PERCENT expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
## conditional -> expr . QUESTION_MARK expr COLON expr [ RBRACE QUESTION_MARK PLUS PERCENT NOT_EQUAL NEWLINE MULT MINUS LOG_OR LOG_AND LESS_THAN_EQUAL LESS_THAN IS_EQUAL GREATER_THAN_EQUAL GREATER_THAN DIV ]
##
## The known suffix of the stack is as follows:
## identifier EQUAL expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
##

Unexpected closing bracket.

main: IDENTIFIER LBRACE NEWLINE FALSE EQUAL FALSE NEWLINE EOF
##
## Ends in an error in state: 242.
##
## block -> IDENTIFIER block_labels LBRACE nonempty_list(NEWLINE) body . RBRACE [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER block_labels LBRACE nonempty_list(NEWLINE) body
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 15, spurious reduction of production nonempty_list(NEWLINE) -> NEWLINE
## In state 251, spurious reduction of production body ->
## In state 252, spurious reduction of production body -> attribute nonempty_list(NEWLINE) body
##

Premature end of file.

main: IDENTIFIER LBRACE RBRACE TRUE
##
## Ends in an error in state: 244.
##
## body -> block_one_line . nonempty_list(NEWLINE) body [ RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## block_one_line
##

Expected new line after block, found expression.

main: IDENTIFIER LBRACE RBRACE NEWLINE STRING
##
## Ends in an error in state: 245.
##
## body -> block_one_line nonempty_list(NEWLINE) . body [ RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## block_one_line nonempty_list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 15, spurious reduction of production nonempty_list(NEWLINE) -> NEWLINE
##

Unexpected literal after block.

main: IDENTIFIER LBRACE NEWLINE RBRACE TRUE
##
## Ends in an error in state: 247.
##
## body -> block . nonempty_list(NEWLINE) body [ RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## block
##

Newline expected after closing brace for block.

main: IDENTIFIER LBRACE NEWLINE RBRACE NEWLINE STRING
##
## Ends in an error in state: 248.
##
## body -> block nonempty_list(NEWLINE) . body [ RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## block nonempty_list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 15, spurious reduction of production nonempty_list(NEWLINE) -> NEWLINE
##

Unexpected literal after block.

main: FALSE EQUAL FALSE RBRACE
##
## Ends in an error in state: 250.
##
## body -> attribute . nonempty_list(NEWLINE) body [ RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## attribute
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
## In state 241, spurious reduction of production attribute -> identifier EQUAL expr
##

Unexpected closing brace.

main: FALSE EQUAL FALSE NEWLINE STRING
##
## Ends in an error in state: 251.
##
## body -> attribute nonempty_list(NEWLINE) . body [ RBRACE EOF ]
##
## The known suffix of the stack is as follows:
## attribute nonempty_list(NEWLINE)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 15, spurious reduction of production nonempty_list(NEWLINE) -> NEWLINE
##

Unexpected literal after after attribute.

main: IDENTIFIER LBRACE FALSE EQUAL FALSE NEWLINE
##
## Ends in an error in state: 253.
##
## block_one_line -> IDENTIFIER block_labels LBRACE attribute . RBRACE [ NEWLINE ]
##
## The known suffix of the stack is as follows:
## IDENTIFIER block_labels LBRACE attribute
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 63, spurious reduction of production expr -> expr_term
## In state 241, spurious reduction of production attribute -> identifier EQUAL expr
##

Single-line block must be closed on same line.

main: FALSE EQUAL FALSE NEWLINE RBRACE
##
## Ends in an error in state: 255.
##
## main -> list(NEWLINE) body . EOF [ # ]
##
## The known suffix of the stack is as follows:
## list(NEWLINE) body
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 15, spurious reduction of production nonempty_list(NEWLINE) -> NEWLINE
## In state 251, spurious reduction of production body ->
## In state 252, spurious reduction of production body -> attribute nonempty_list(NEWLINE) body
##

Unexpected closing brace.

